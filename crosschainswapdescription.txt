# **Complete ResolverX Cross-Chain Swap Documentation**

## **Table of Contents**
1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Contract Deployment](#contract-deployment)
4. [Complete Swap Workflow](#complete-swap-workflow)
5. [Function Call Sequence](#function-call-sequence)
6. [Source vs Destination](#source-vs-destination)
7. [Remix Deployment Guide](#remix-deployment-guide)
8. [Security Mechanisms](#security-mechanisms)
9. [Timelock System](#timelock-system)
10. [Error Handling](#error-handling)

---

## **1. Overview**

The ResolverX Cross-Chain Swap system enables **atomic cross-chain swaps** between Ethereum (Sepolia) and TRON (Nile testnet) using a single HTLC (Hashed Timelock Contract) deployed on both chains. The system ensures that either both parties receive their desired tokens or neither does, preventing partial execution.

### **Key Components:**
- **AtomicSwap Contract**: Single HTLC contract deployed on both chains
- **Backend API**: Node.js + Express to coordinate swaps
- **Relayer Bot**: Monitors both chains for secret reveals
- **Resolver Bot**: Template for liquidity providers
- **Frontend UI**: User interface for swaps

---

## **2. Architecture**

### **Contract Structure:**
```
AtomicSwap Contract (Same on both chains)
â”œâ”€â”€ lock() - Lock funds with hashlock
â”œâ”€â”€ claim() - Claim funds with preimage
â””â”€â”€ refund() - Refund after timelock expires
```

### **Network Setup:**
```
Ethereum (Sepolia Testnet)
â””â”€â”€ AtomicSwap Contract

TRON (Nile Testnet)  
â””â”€â”€ AtomicSwap Contract
```

---

## **3. Contract Deployment**

### **Contracts to Deploy:**

#### **Single Contract on Each Network:**
1. `HTLC_Contract.sol` - AtomicSwap contract (same on both chains)

### **Deployment Parameters:**

#### **For Both Ethereum (Sepolia) and TRON (Nile):**
```solidity
// No constructor parameters needed
AtomicSwap atomicSwap = new AtomicSwap();
```

---

## **4. Complete Swap Workflow**

### **Example: ETH â†’ TRX Swap**

#### **Phase 1: Setup (Pre-Swap)**
```solidity
// 1. Backend generates random secret and hashlock
bytes32 secret = generateRandomSecret();
bytes32 hashlock = keccak256(abi.encodePacked(secret));

// 2. User locks ETH on Ethereum (Sepolia)
atomicSwap.lock(
    hashlock,           // H = hash(s)
    resolverAddress,    // Resolver's address (recipient)
    address(0),         // Native ETH
    amount,             // ETH amount
    timelock            // Expiry timestamp
);
```

#### **Phase 2: Destination Chain Lock (TRON)**
```solidity
// 3. Resolver locks TRX on TRON (Nile)
atomicSwap.lock(
    hashlock,           // Same hashlock
    userAddress,        // User's address (recipient)
    address(0),         // Native TRX
    amount,             // TRX amount
    timelock            // Same expiry
);
```

#### **Phase 3: Claim (Using Secret)**
```solidity
// 4. User claims TRX on TRON using secret
atomicSwap.claim(secret);

// 5. Relayer bot extracts secret from TRON chain
// 6. Relayer calls resolver's claim function on Ethereum
atomicSwap.claim(secret); // Resolver claims ETH
```

---

## **5. Function Call Sequence**

### **Complete Function Call Flow:**

#### **Setup Phase:**
1. Backend generates secret and hashlock
2. User approves ETH spending (if needed)

#### **Source Chain (Ethereum Sepolia):**
3. `atomicSwap.lock()` - User locks ETH
4. Backend monitors for HTLCLocked event

#### **Destination Chain (TRON Nile):**
5. `atomicSwap.lock()` - Resolver locks TRX
6. Backend monitors for HTLCLocked event

#### **Claim Phase:**
7. `atomicSwap.claim()` - User claims TRX on TRON
8. Relayer extracts secret from claim transaction
9. `atomicSwap.claim()` - Resolver claims ETH on Ethereum

#### **Refund Phase (if needed):**
10. `atomicSwap.refund()` - User refunds ETH if swap fails
11. `atomicSwap.refund()` - Resolver refunds TRX if swap fails

---

## **6. Source vs Destination**

### **Source Chain (Ethereum Sepolia in ETHâ†’TRX):**
- **Purpose**: Where user's original tokens are locked
- **Lock**: User locks ETH, recipient is resolver
- **Claim**: Resolver claims ETH using secret
- **Refund**: User gets ETH back if swap fails

### **Destination Chain (TRON Nile in ETHâ†’TRX):**
- **Purpose**: Where user receives their desired tokens
- **Lock**: Resolver locks TRX, recipient is user
- **Claim**: User claims TRX using secret
- **Refund**: Resolver gets TRX back if swap fails

### **Key Differences:**

| Aspect | Source Chain | Destination Chain |
|--------|--------------|-------------------|
| **Token Flow** | User â†’ Contract | Resolver â†’ Contract â†’ User |
| **Lock Recipient** | Resolver | User |
| **Claim Caller** | Resolver | User |
| **Refund Caller** | User | Resolver |

---

## **7. Remix Deployment Guide**

### **Step-by-Step Remix Setup:**

#### **Step 1: Create Workspace**
1. Open [Remix IDE](https://remix.ethereum.org/)
2. Create new workspace: "ResolverX-cross-chain-swap"
3. Upload `HTLC_Contract.sol`

#### **Step 2: Configure Compiler**
1. Go to **Solidity Compiler** tab
2. Set compiler version: **0.8.0 or higher**
3. Enable optimization: **200 runs**

#### **Step 3: Compile**
1. Click **Compile HTLC_Contract.sol**
2. Ensure no compilation errors

#### **Step 4: Deploy**
1. Go to **Deploy & Run Transactions** tab
2. Select `AtomicSwap` contract
3. No constructor parameters needed
4. Deploy on both networks:
   - **Ethereum Sepolia testnet**
   - **TRON Nile testnet**

#### **Step 5: Verify Deployment**
After deployment, call these functions to verify:
```solidity
// Check contract is working
// Try creating a test swap
```

---

## **8. Security Mechanisms**

### **1. Secret-Based Unlocking**
```solidity
// Secret is randomly generated by backend
bytes32 secret = generateRandomSecret();
bytes32 hashlock = keccak256(abi.encodePacked(secret));

// Only correct secret unlocks funds
require(keccak256(abi.encodePacked(_preimage)) == s.hashlock, "Invalid secret");
```

### **2. Timelock Protection**
```solidity
// Funds can only be claimed before timelock expires
require(block.timestamp < s.timelock, "Expired");

// Funds can only be refunded after timelock expires
require(block.timestamp >= s.timelock, "Too early");
```

### **3. State Management**
```solidity
enum State { INVALID, OPEN, CLAIMED, REFUNDED }
// Prevents double-spending and invalid operations
```

### **4. Access Control**
```solidity
// Only recipient can claim
require(msg.sender == s.recipient, "Not recipient");

// Only sender can refund
require(msg.sender == s.sender, "Not sender");
```

---

## **9. Timelock System**

### **Timelock Structure:**
```solidity
uint256 timelock; // Unix timestamp when refund becomes available
```

### **Time Flow Example:**
```
[Lock] --30min--> [Claim Window] --30min--> [Refund Available]
```

### **Timelock Functions:**
```solidity
// Check if claim is still valid
require(block.timestamp < s.timelock, "Expired");

// Check if refund is available
require(block.timestamp >= s.timelock, "Too early");
```

---

## **10. Error Handling**

### **Common Errors:**

#### **1. Already Exists**
```solidity
require(swaps[_hashlock].state == State.INVALID, "Already exists");
// Thrown when trying to create duplicate swap
```

#### **2. Not Open**
```solidity
require(s.state == State.OPEN, "Not open");
// Thrown when swap is not in OPEN state
```

#### **3. Expired**
```solidity
require(block.timestamp < s.timelock, "Expired");
// Thrown when trying to claim after timelock
```

#### **4. Too Early**
```solidity
require(block.timestamp >= s.timelock, "Too early");
// Thrown when trying to refund before timelock
```

#### **5. Not Recipient/Sender**
```solidity
require(msg.sender == s.recipient, "Not recipient");
require(msg.sender == s.sender, "Not sender");
// Thrown when unauthorized address calls function
```

---

## **Summary**

### **Key Points:**
1. **Single contract** deployed on both chains
2. **Same contract** for both Ethereum and TRON
3. **Secret-based** unlocking ensures atomic swaps
4. **Timelock system** prevents indefinite locking
5. **State management** prevents double-spending

### **Deployment Checklist:**
- âœ… Upload HTLC_Contract.sol to Remix
- âœ… Compile with Solidity 0.8.0+
- âœ… Deploy on Ethereum Sepolia testnet
- âœ… Deploy on TRON Nile testnet
- âœ… Test basic lock/claim/refund functionality

This simplified system ensures **atomic cross-chain swaps** with strong security mechanisms and clear state management! ðŸš€