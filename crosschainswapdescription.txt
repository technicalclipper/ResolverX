# **Complete 1inch Cross-Chain Swap Documentation**

## **Table of Contents**
1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Contract Deployment](#contract-deployment)
4. [Complete Swap Workflow](#complete-swap-workflow)
5. [Function Call Sequence](#function-call-sequence)
6. [Source vs Destination](#source-vs-destination)
7. [Remix Deployment Guide](#remix-deployment-guide)
8. [Security Mechanisms](#security-mechanisms)
9. [Timelock System](#timelock-system)
10. [Error Handling](#error-handling)

---

## **1. Overview**

The 1inch Cross-Chain Swap system enables **atomic cross-chain swaps** between different blockchain networks (e.g., Ethereum â†” TRON) using escrow contracts and the Limit Order Protocol (LOP). The system ensures that either both parties receive their desired tokens or neither does, preventing partial execution.

### **Key Components:**
- **EscrowFactory**: Main factory contract that deploys escrow clones
- **EscrowSrc**: Source chain escrow that holds user's tokens initially
- **EscrowDst**: Destination chain escrow that holds resolver's tokens
- **Limit Order Protocol**: Handles order creation and execution
- **Resolver**: Facilitates the cross-chain swap process

---

## **2. Architecture**

### **Contract Hierarchy:**
```
EscrowFactory (Main Factory)
â”œâ”€â”€ BaseEscrowFactory (Abstract Base)
â”œâ”€â”€ EscrowSrc (Source Chain Escrow)
â”œâ”€â”€ EscrowDst (Destination Chain Escrow)
â”œâ”€â”€ BaseEscrow (Abstract Base Escrow)
â””â”€â”€ Escrow (Abstract Escrow)
```

### **Network Setup:**
```
Ethereum (Source Chain)
â”œâ”€â”€ EscrowFactory
â”œâ”€â”€ EscrowSrc Implementation
â””â”€â”€ EscrowDst Implementation

TRON (Destination Chain)
â”œâ”€â”€ EscrowFactory
â”œâ”€â”€ EscrowSrc Implementation
â””â”€â”€ EscrowDst Implementation
```

---

## **3. Contract Deployment**

### **Contracts to Deploy on Each Network:**

#### **For Both Ethereum and TRON:**

**Main Contracts:**
1. `EscrowFactory.sol` - Main factory contract
2. `BaseEscrowFactory.sol` - Abstract base factory
3. `EscrowSrc.sol` - Source chain escrow implementation
4. `EscrowDst.sol` - Destination chain escrow implementation
5. `BaseEscrow.sol` - Abstract base escrow
6. `Escrow.sol` - Abstract escrow
7. `MerkleStorageInvalidator.sol` - Merkle tree validation
8. `EscrowFactoryContext.sol` - Context constants

**Libraries:**
9. `libraries/ImmutablesLib.sol` - Immutables handling
10. `libraries/TimelocksLib.sol` - Timelock management
11. `libraries/ProxyHashLib.sol` - Proxy bytecode hashing

**Interfaces:**
12. `interfaces/IBaseEscrow.sol` - Base escrow interface
13. `interfaces/IEscrow.sol` - Escrow interface
14. `interfaces/IEscrowSrc.sol` - Source escrow interface
15. `interfaces/IEscrowDst.sol` - Destination escrow interface
16. `interfaces/IEscrowFactory.sol` - Factory interface
17. `interfaces/IMerkleStorageInvalidator.sol` - Merkle invalidator interface
18. `interfaces/IResolverExample.sol` - Resolver example interface

**Total: 18 files per network**

### **Deployment Parameters:**

#### **Ethereum:**
```solidity
EscrowFactory factory = new EscrowFactory(
    0x111111125421cA6dc452d289314280a0f8842A65, // LOP
    0x6B175474E89094C44Da98b954EedeAC495271d0F, // DAI
    0xACCe550000159e70908C0499a1119D04e7039C28, // Access Token
    ownerAddress,
    691200, // Rescue delay (8 days)
    691200  // Rescue delay (8 days)
);
```

#### **TRON:**
```solidity
EscrowFactory factory = new EscrowFactory(
    0x111111125421cA6dc452d289314280a0f8842A65, // LOP (same)
    [TRON_DAI_ADDRESS],                          // TRON DAI equivalent
    0xACCe550000159e70908C0499a1119D04e7039C28, // Access Token (same)
    ownerAddress,
    691200, // Rescue delay (8 days)
    691200  // Rescue delay (8 days)
);
```

---

## **4. Complete Swap Workflow**

### **Example: ETH â†’ TRON Swap**

#### **Phase 1: Setup (Pre-Swap)**
```solidity
// 1. User creates limit order on Ethereum
IOrderMixin.Order memory order = {
    maker: userAddress,           // User's address
    receiver: address(0),         // No specific receiver
    makerAsset: ETH_ADDRESS,      // ETH token address
    takerAsset: FAKE_TOKEN,       // Fake token (always returns true)
    makingAmount: 1 ether,        // 1 ETH
    takingAmount: 1 ether,        // 1 ETH worth of fake token
    makerTraits: makerTraits      // Order parameters
};

// 2. User signs the order
bytes32 orderHash = keccak256(abi.encode(order));
(uint8 v, bytes32 r, bytes32 s) = vm.sign(userPrivateKey, orderHash);
```

#### **Phase 2: Source Chain Escrow Creation (Ethereum)**
```solidity
// 3. Resolver calls Limit Order Protocol
limitOrderProtocol.fillOrderArgs(
    order,
    r,
    vs,
    makingAmount,
    takerTraits,
    args
);

// 4. LOP automatically calls EscrowFactory._postInteraction()
function _postInteraction(...) internal override {
    // Extract swap parameters
    ExtraDataArgs calldata extraDataArgs = /* extract from extraData */;
    
    // Create immutables for EscrowSrc
    IBaseEscrow.Immutables memory immutables = {
        orderHash: orderHash,
        hashlock: extraDataArgs.hashlockInfo,  // Hash of secret
        maker: order.maker,                    // User's address
        taker: Address.wrap(uint160(taker)),   // Resolver's address
        token: order.makerAsset,               // ETH token
        amount: makingAmount,                  // 1 ETH
        safetyDeposit: extraDataArgs.deposits >> 128,  // Safety deposit
        timelocks: extraDataArgs.timelocks.setDeployedAt(block.timestamp)
    };
    
    // Deploy EscrowSrc clone
    bytes32 salt = immutables.hashMem();
    address escrow = _deployEscrow(salt, 0, ESCROW_SRC_IMPLEMENTATION);
    
    // Verify ETH tokens are locked
    if (escrow.balance < immutables.safetyDeposit || 
        IERC20(order.makerAsset.get()).safeBalanceOf(escrow) < makingAmount) {
        revert InsufficientEscrowBalance();
    }
}
```

#### **Phase 3: Destination Chain Escrow Creation (TRON)**
```solidity
// 5. Resolver calls createDstEscrow on TRON
function createDstEscrow(
    IBaseEscrow.Immutables calldata dstImmutables, 
    uint256 srcCancellationTimestamp
) external payable {
    // Validate native token amount
    address token = dstImmutables.token.get();
    uint256 nativeAmount = dstImmutables.safetyDeposit;
    if (token == address(0)) {
        nativeAmount += dstImmutables.amount;  // TRX amount + safety deposit
    }
    if (msg.value != nativeAmount) revert InsufficientEscrowBalance();
    
    // Set deployment timestamp
    IBaseEscrow.Immutables memory immutables = dstImmutables;
    immutables.timelocks = immutables.timelocks.setDeployedAt(block.timestamp);
    
    // Validate timelock coordination
    if (immutables.timelocks.get(TimelocksLib.Stage.DstCancellation) > srcCancellationTimestamp) {
        revert InvalidCreationTime();
    }
    
    // Deploy EscrowDst clone
    bytes32 salt = immutables.hashMem();
    address escrow = _deployEscrow(salt, msg.value, ESCROW_DST_IMPLEMENTATION);
    
    // Transfer TRX tokens to escrow
    if (token != address(0)) {
        IERC20(token).safeTransferFrom(msg.sender, escrow, immutables.amount);
    }
}
```

#### **Phase 4: Withdrawal (Using Secret)**
```solidity
// 6. Resolver withdraws from Source Chain (Ethereum)
function withdraw(bytes32 secret, Immutables calldata immutables) external {
    // Verify caller is taker (resolver)
    require(msg.sender == immutables.taker.get(), "InvalidCaller");
    
    // Verify timelock (after withdrawal period)
    require(block.timestamp >= immutables.timelocks.get(TimelocksLib.Stage.SrcWithdrawal), "InvalidTime");
    require(block.timestamp < immutables.timelocks.get(TimelocksLib.Stage.SrcCancellation), "InvalidTime");
    
    // Call internal withdrawal
    _withdrawTo(secret, msg.sender, immutables);
}

function _withdrawTo(bytes32 secret, address target, Immutables calldata immutables) internal {
    // Verify immutables match
    require(/* immutables validation */, "InvalidImmutables");
    
    // Verify secret matches hashlock
    require(keccak256(abi.encode(secret)) == immutables.hashlock, "InvalidSecret");
    
    // Transfer tokens
    IERC20(immutables.token.get()).safeTransfer(target, immutables.amount);  // 1 ETH to resolver
    _ethTransfer(msg.sender, immutables.safetyDeposit);  // Safety deposit to resolver
    
    emit EscrowWithdrawal(secret);
}

// 7. Resolver withdraws from Destination Chain (TRON)
function withdraw(bytes32 secret, Immutables calldata immutables) external {
    // Verify caller is taker (resolver)
    require(msg.sender == immutables.taker.get(), "InvalidCaller");
    
    // Verify timelock
    require(block.timestamp >= immutables.timelocks.get(TimelocksLib.Stage.DstWithdrawal), "InvalidTime");
    require(block.timestamp < immutables.timelocks.get(TimelocksLib.Stage.DstCancellation), "InvalidTime");
    
    // Call internal withdrawal
    _withdraw(secret, immutables);
}

function _withdraw(bytes32 secret, Immutables calldata immutables) internal {
    // Verify immutables and secret
    require(/* validation */, "Invalid");
    
    // Transfer tokens to maker (user)
    _uniTransfer(immutables.token.get(), immutables.maker.get(), immutables.amount);  // TRX to user
    _ethTransfer(msg.sender, immutables.safetyDeposit);  // Safety deposit to resolver
    
    emit EscrowWithdrawal(secret);
}
```

---

## **5. Function Call Sequence**

### **Complete Function Call Flow:**

#### **Setup Phase:**
1. `EscrowFactory.addressOfEscrowSrc()` - Get future escrow address
2. `EscrowFactory.addressOfEscrowDst()` - Get future escrow address

#### **Source Chain (Ethereum):**
3. `limitOrderProtocol.fillOrderArgs()` - Fill order (triggers escrow deployment)
4. `EscrowFactory._postInteraction()` - Called automatically by LOP
5. `EscrowFactory._deployEscrow()` - Deploy EscrowSrc clone
6. `IERC20.safeTransfer()` - Transfer ETH to escrow

#### **Destination Chain (TRON):**
7. `EscrowFactory.createDstEscrow()` - Deploy EscrowDst clone
8. `IERC20.safeTransferFrom()` - Transfer TRX to escrow

#### **Withdrawal Phase:**
9. `EscrowSrc.withdraw()` - Withdraw ETH from source escrow
10. `EscrowDst.withdraw()` - Withdraw TRX from destination escrow

#### **Cancellation Phase (if needed):**
11. `EscrowSrc.cancel()` - Cancel source escrow
12. `EscrowDst.cancel()` - Cancel destination escrow

#### **Emergency Functions:**
13. `EscrowSrc.publicWithdraw()` - Public withdrawal on source
14. `EscrowDst.publicWithdraw()` - Public withdrawal on destination
15. `EscrowSrc.publicCancel()` - Public cancellation on source
16. `BaseEscrow.rescueFunds()` - Emergency fund recovery

---

## **6. Source vs Destination**

### **Source Chain (Ethereum in ETHâ†’TRON):**
- **Purpose**: Where user's original tokens are locked
- **Escrow**: `EscrowSrc` holds ETH tokens
- **Deployment**: Triggered by order fill through LOP
- **Withdrawal**: Resolver withdraws ETH to themselves
- **Cancellation**: User gets ETH back if swap fails

### **Destination Chain (TRON in ETHâ†’TRON):**
- **Purpose**: Where user receives their desired tokens
- **Escrow**: `EscrowDst` holds TRX tokens
- **Deployment**: Manual call by resolver
- **Withdrawal**: Resolver sends TRX to user
- **Cancellation**: Resolver gets TRX back if swap fails

### **Key Differences:**

| Aspect | Source Chain | Destination Chain |
|--------|--------------|-------------------|
| **Token Flow** | User â†’ Escrow | Resolver â†’ Escrow â†’ User |
| **Deployment Trigger** | Order fill (automatic) | Manual resolver call |
| **Withdrawal Recipient** | Resolver | User |
| **Cancellation Recipient** | User (original owner) | Resolver (original owner) |
| **Timelock Priority** | Higher priority | Lower priority |

---

## **7. Remix Deployment Guide**

### **Step-by-Step Remix Setup:**

#### **Step 1: Create Workspace**
1. Open [Remix IDE](https://remix.ethereum.org/)
2. Create new workspace: "1inch-cross-chain-swap"
3. Create folder structure:
   ```
   contracts/
   â”œâ”€â”€ libraries/
   â””â”€â”€ interfaces/
   ```

#### **Step 2: Add All Required Files**
Copy these 18 files to Remix:

**Main Contracts (8 files):**
```
contracts/
â”œâ”€â”€ EscrowFactory.sol
â”œâ”€â”€ BaseEscrowFactory.sol
â”œâ”€â”€ EscrowSrc.sol
â”œâ”€â”€ EscrowDst.sol
â”œâ”€â”€ BaseEscrow.sol
â”œâ”€â”€ Escrow.sol
â”œâ”€â”€ MerkleStorageInvalidator.sol
â””â”€â”€ EscrowFactoryContext.sol
```

**Libraries (3 files):**
```
contracts/libraries/
â”œâ”€â”€ ImmutablesLib.sol
â”œâ”€â”€ TimelocksLib.sol
â””â”€â”€ ProxyHashLib.sol
```

**Interfaces (7 files):**
```
contracts/interfaces/
â”œâ”€â”€ IBaseEscrow.sol
â”œâ”€â”€ IEscrow.sol
â”œâ”€â”€ IEscrowSrc.sol
â”œâ”€â”€ IEscrowDst.sol
â”œâ”€â”€ IEscrowFactory.sol
â”œâ”€â”€ IMerkleStorageInvalidator.sol
â””â”€â”€ IResolverExample.sol
```

#### **Step 3: Configure Compiler**
1. Go to **Solidity Compiler** tab
2. Set compiler version: **0.8.23**
3. Enable optimization: **1000000 runs**
4. Set **via-IR**: true (if available)

#### **Step 4: Install Dependencies**
1. Go to **Package Manager** tab
2. Install packages:
   ```
   openzeppelin-contracts
   limit-order-protocol
   limit-order-settlement
   solidity-utils
   ```

#### **Step 5: Compile**
1. Click **Compile EscrowFactory.sol**
2. Ensure no compilation errors

#### **Step 6: Deploy**
1. Go to **Deploy & Run Transactions** tab
2. Select `EscrowFactory` contract
3. Set constructor parameters:

**For Ethereum:**
```solidity
limitOrderProtocol: 0x111111125421cA6dc452d289314280a0f8842A65
feeToken: 0x6B175474E89094C44Da98b954EedeAC495271d0F (DAI)
accessToken: 0xACCe550000159e70908C0499a1119D04e7039C28
owner: [Your Address]
rescueDelaySrc: 691200 (8 days)
rescueDelayDst: 691200 (8 days)
```

**For TRON:**
```solidity
limitOrderProtocol: 0x111111125421cA6dc452d289314280a0f8842A65
feeToken: [TRON DAI equivalent address]
accessToken: 0xACCe550000159e70908C0499a1119D04e7039C28
owner: [Your Address]
rescueDelaySrc: 691200 (8 days)
rescueDelayDst: 691200 (8 days)
```

#### **Step 7: Verify Deployment**
After deployment, call these functions to verify:
```solidity
// Check implementations were deployed
address srcImpl = factory.ESCROW_SRC_IMPLEMENTATION();
address dstImpl = factory.ESCROW_DST_IMPLEMENTATION();

// Should return valid addresses (not zero)
```

---

## **8. Security Mechanisms**

### **1. Secret-Based Unlocking**
```solidity
// Secret is hash of user's private key
bytes32 secret = keccak256(abi.encode(userPrivateKey));
bytes32 hashlock = keccak256(abi.encode(secret));

// Only correct secret unlocks escrows
require(keccak256(abi.encode(secret)) == immutables.hashlock, "InvalidSecret");
```

### **2. Deterministic Addresses**
```solidity
// Escrow addresses computed from swap parameters
bytes32 salt = immutables.hashMem();
address escrow = Create2.computeAddress(salt, PROXY_BYTECODE_HASH, FACTORY);

// Prevents front-running attacks
```

### **3. Timelock Protection**
```solidity
// Different time windows for different operations
enum Stage {
    SrcWithdrawal,        // Private withdrawal on source
    SrcPublicWithdrawal,  // Public withdrawal on source
    SrcCancellation,      // Private cancellation on source
    SrcPublicCancellation, // Public cancellation on source
    DstWithdrawal,        // Private withdrawal on destination
    DstPublicWithdrawal,  // Public withdrawal on destination
    DstCancellation       // Cancellation on destination
}
```

### **4. Access Token System**
```solidity
// Public operations require access token
modifier onlyAccessTokenHolder() {
    if (_ACCESS_TOKEN.balanceOf(msg.sender) == 0) revert InvalidCaller();
    _;
}
```

### **5. Safety Deposits**
```solidity
// Incentivize resolvers to complete swaps
uint256 safetyDeposit = extraDataArgs.deposits >> 128;
_ethTransfer(msg.sender, immutables.safetyDeposit);
```

---

## **9. Timelock System**

### **Timelock Structure:**
```solidity
struct SrcTimelocks {
    uint32 withdrawal;        // Private withdrawal period
    uint32 publicWithdrawal;  // Public withdrawal period
    uint32 cancellation;      // Private cancellation period
    uint32 publicCancellation; // Public cancellation period
}

struct DstTimelocks {
    uint32 withdrawal;        // Private withdrawal period
    uint32 publicWithdrawal;  // Public withdrawal period
    uint32 cancellation;      // Cancellation period
}
```

### **Time Flow Example:**
```
Source Chain (Ethereum):
[Deploy] --5min--> [Private Withdrawal] --5min--> [Public Withdrawal] --5min--> [Private Cancel] --5min--> [Public Cancel]

Destination Chain (TRON):
[Deploy] --5min--> [Private Withdrawal] --5min--> [Public Withdrawal] --5min--> [Cancel]
```

### **Timelock Functions:**
```solidity
// Get timelock value for specific stage
function get(Timelocks timelocks, Stage stage) internal pure returns (uint256) {
    uint256 data = Timelocks.unwrap(timelocks);
    uint256 bitShift = uint256(stage) * 32;
    return (data >> _DEPLOYED_AT_OFFSET) + uint32(data >> bitShift);
}

// Set deployment timestamp
function setDeployedAt(Timelocks timelocks, uint256 value) internal pure returns (Timelocks) {
    return Timelocks.wrap((Timelocks.unwrap(timelocks) & ~uint256(_DEPLOYED_AT_MASK)) | value << _DEPLOYED_AT_OFFSET);
}
```

---

## **10. Error Handling**

### **Common Errors:**

#### **1. Insufficient Balance**
```solidity
error InsufficientEscrowBalance();
// Thrown when escrow doesn't have required tokens
```

#### **2. Invalid Timelock**
```solidity
error InvalidTime();
// Thrown when operation attempted outside allowed time window
```

#### **3. Invalid Secret**
```solidity
error InvalidSecret();
// Thrown when secret doesn't match hashlock
```

#### **4. Invalid Caller**
```solidity
error InvalidCaller();
// Thrown when unauthorized address calls function
```

#### **5. Invalid Creation Time**
```solidity
error InvalidCreationTime();
// Thrown when destination escrow creation timing is invalid
```

### **Error Recovery:**
```solidity
// Emergency fund rescue
function rescueFunds(address token, uint256 amount, Immutables calldata immutables) external {
    require(msg.sender == immutables.taker.get(), "InvalidCaller");
    require(block.timestamp >= immutables.timelocks.rescueStart(RESCUE_DELAY), "InvalidTime");
    
    _uniTransfer(token, msg.sender, amount);
    emit FundsRescued(token, amount);
}
```

---

## **Summary**

### **Key Points:**
1. **18 files** need to be added to Remix for each network
2. **Same files** for both Ethereum and TRON (only parameters differ)
3. **EscrowSrc** deployed automatically when order is filled
4. **EscrowDst** deployed manually by resolver
5. **Secret-based** unlocking ensures atomic swaps
6. **Timelock system** prevents indefinite locking
7. **Safety deposits** incentivize proper execution

### **Deployment Checklist:**
- âœ… Add all 18 contract files to Remix
- âœ… Install external dependencies
- âœ… Set correct compiler settings
- âœ… Deploy EscrowFactory with correct parameters
- âœ… Verify implementation addresses
- âœ… Test basic functionality

This system ensures **atomic cross-chain swaps** where either both parties get their desired tokens or neither does, with strong security mechanisms and economic incentives for proper execution! ðŸš€