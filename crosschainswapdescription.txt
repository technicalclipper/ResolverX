# **Complete 1inch Cross-Chain Swap Documentation**

## **Table of Contents**
1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Contract Deployment](#contract-deployment)
4. [Complete Swap Workflow](#complete-swap-workflow)
5. [Function Call Sequence](#function-call-sequence)
6. [Source vs Destination](#source-vs-destination)
7. [Remix Deployment Guide](#remix-deployment-guide)
8. [Security Mechanisms](#security-mechanisms)
9. [Timelock System](#timelock-system)
10. [Error Handling](#error-handling)

---

## **1. Overview**

The 1inch Cross-Chain Swap system enables **atomic cross-chain swaps** between different blockchain networks (e.g., Ethereum ↔ TRON) using escrow contracts and the Limit Order Protocol (LOP). The system ensures that either both parties receive their desired tokens or neither does, preventing partial execution.

### **Key Components:**
- **EscrowFactory**: Main factory contract that deploys escrow clones
- **EscrowSrc**: Source chain escrow that holds user's tokens initially
- **EscrowDst**: Destination chain escrow that holds resolver's tokens
- **Limit Order Protocol**: Handles order creation and execution
- **Resolver**: Facilitates the cross-chain swap process

---

## **2. Architecture**

### **Contract Hierarchy:**
```
EscrowFactory (Main Factory)
├── BaseEscrowFactory (Abstract Base)
├── EscrowSrc (Source Chain Escrow)
├── EscrowDst (Destination Chain Escrow)
├── BaseEscrow (Abstract Base Escrow)
└── Escrow (Abstract Escrow)
```

### **Network Setup:**
```
Ethereum (Source Chain)
├── EscrowFactory
├── EscrowSrc Implementation
└── EscrowDst Implementation

TRON (Destination Chain)
├── EscrowFactory
├── EscrowSrc Implementation
└── EscrowDst Implementation
```

---

## **3. Contract Deployment**

### **Contracts to Deploy on Each Network:**

#### **For Both Ethereum and TRON:**

**Main Contracts:**
1. `EscrowFactory.sol` - Main factory contract
2. `BaseEscrowFactory.sol` - Abstract base factory
3. `EscrowSrc.sol` - Source chain escrow implementation
4. `EscrowDst.sol` - Destination chain escrow implementation
5. `BaseEscrow.sol` - Abstract base escrow
6. `Escrow.sol` - Abstract escrow
7. `MerkleStorageInvalidator.sol` - Merkle tree validation
8. `EscrowFactoryContext.sol` - Context constants

**Libraries:**
9. `libraries/ImmutablesLib.sol` - Immutables handling
10. `libraries/TimelocksLib.sol` - Timelock management
11. `libraries/ProxyHashLib.sol` - Proxy bytecode hashing

**Interfaces:**
12. `interfaces/IBaseEscrow.sol` - Base escrow interface
13. `interfaces/IEscrow.sol` - Escrow interface
14. `interfaces/IEscrowSrc.sol` - Source escrow interface
15. `interfaces/IEscrowDst.sol` - Destination escrow interface
16. `interfaces/IEscrowFactory.sol` - Factory interface
17. `interfaces/IMerkleStorageInvalidator.sol` - Merkle invalidator interface
18. `interfaces/IResolverExample.sol` - Resolver example interface

**Total: 18 files per network**

### **Deployment Parameters:**

#### **Ethereum:**
```solidity
EscrowFactory factory = new EscrowFactory(
    0x111111125421cA6dc452d289314280a0f8842A65, // LOP
    0x6B175474E89094C44Da98b954EedeAC495271d0F, // DAI
    0xACCe550000159e70908C0499a1119D04e7039C28, // Access Token
    ownerAddress,
    691200, // Rescue delay (8 days)
    691200  // Rescue delay (8 days)
);
```

#### **TRON:**
```solidity
EscrowFactory factory = new EscrowFactory(
    0x111111125421cA6dc452d289314280a0f8842A65, // LOP (same)
    [TRON_DAI_ADDRESS],                          // TRON DAI equivalent
    0xACCe550000159e70908C0499a1119D04e7039C28, // Access Token (same)
    ownerAddress,
    691200, // Rescue delay (8 days)
    691200  // Rescue delay (8 days)
);
```

---

## **4. Complete Swap Workflow**

### **Example: ETH → TRON Swap**

#### **Phase 1: Setup (Pre-Swap)**
```solidity
// 1. User creates limit order on Ethereum
IOrderMixin.Order memory order = {
    maker: userAddress,           // User's address
    receiver: address(0),         // No specific receiver
    makerAsset: ETH_ADDRESS,      // ETH token address
    takerAsset: FAKE_TOKEN,       // Fake token (always returns true)
    makingAmount: 1 ether,        // 1 ETH
    takingAmount: 1 ether,        // 1 ETH worth of fake token
    makerTraits: makerTraits      // Order parameters
};

// 2. User signs the order
bytes32 orderHash = keccak256(abi.encode(order));
(uint8 v, bytes32 r, bytes32 s) = vm.sign(userPrivateKey, orderHash);
```

#### **Phase 2: Source Chain Escrow Creation (Ethereum)**
```solidity
// 3. Resolver calls Limit Order Protocol
limitOrderProtocol.fillOrderArgs(
    order,
    r,
    vs,
    makingAmount,
    takerTraits,
    args
);

// 4. LOP automatically calls EscrowFactory._postInteraction()
function _postInteraction(...) internal override {
    // Extract swap parameters
    ExtraDataArgs calldata extraDataArgs = /* extract from extraData */;
    
    // Create immutables for EscrowSrc
    IBaseEscrow.Immutables memory immutables = {
        orderHash: orderHash,
        hashlock: extraDataArgs.hashlockInfo,  // Hash of secret
        maker: order.maker,                    // User's address
        taker: Address.wrap(uint160(taker)),   // Resolver's address
        token: order.makerAsset,               // ETH token
        amount: makingAmount,                  // 1 ETH
        safetyDeposit: extraDataArgs.deposits >> 128,  // Safety deposit
        timelocks: extraDataArgs.timelocks.setDeployedAt(block.timestamp)
    };
    
    // Deploy EscrowSrc clone
    bytes32 salt = immutables.hashMem();
    address escrow = _deployEscrow(salt, 0, ESCROW_SRC_IMPLEMENTATION);
    
    // Verify ETH tokens are locked
    if (escrow.balance < immutables.safetyDeposit || 
        IERC20(order.makerAsset.get()).safeBalanceOf(escrow) < makingAmount) {
        revert InsufficientEscrowBalance();
    }
}
```

#### **Phase 3: Destination Chain Escrow Creation (TRON)**
```solidity
// 5. Resolver calls createDstEscrow on TRON
function createDstEscrow(
    IBaseEscrow.Immutables calldata dstImmutables, 
    uint256 srcCancellationTimestamp
) external payable {
    // Validate native token amount
    address token = dstImmutables.token.get();
    uint256 nativeAmount = dstImmutables.safetyDeposit;
    if (token == address(0)) {
        nativeAmount += dstImmutables.amount;  // TRX amount + safety deposit
    }
    if (msg.value != nativeAmount) revert InsufficientEscrowBalance();
    
    // Set deployment timestamp
    IBaseEscrow.Immutables memory immutables = dstImmutables;
    immutables.timelocks = immutables.timelocks.setDeployedAt(block.timestamp);
    
    // Validate timelock coordination
    if (immutables.timelocks.get(TimelocksLib.Stage.DstCancellation) > srcCancellationTimestamp) {
        revert InvalidCreationTime();
    }
    
    // Deploy EscrowDst clone
    bytes32 salt = immutables.hashMem();
    address escrow = _deployEscrow(salt, msg.value, ESCROW_DST_IMPLEMENTATION);
    
    // Transfer TRX tokens to escrow
    if (token != address(0)) {
        IERC20(token).safeTransferFrom(msg.sender, escrow, immutables.amount);
    }
}
```

#### **Phase 4: Withdrawal (Using Secret)**
```solidity
// 6. Resolver withdraws from Source Chain (Ethereum)
function withdraw(bytes32 secret, Immutables calldata immutables) external {
    // Verify caller is taker (resolver)
    require(msg.sender == immutables.taker.get(), "InvalidCaller");
    
    // Verify timelock (after withdrawal period)
    require(block.timestamp >= immutables.timelocks.get(TimelocksLib.Stage.SrcWithdrawal), "InvalidTime");
    require(block.timestamp < immutables.timelocks.get(TimelocksLib.Stage.SrcCancellation), "InvalidTime");
    
    // Call internal withdrawal
    _withdrawTo(secret, msg.sender, immutables);
}

function _withdrawTo(bytes32 secret, address target, Immutables calldata immutables) internal {
    // Verify immutables match
    require(/* immutables validation */, "InvalidImmutables");
    
    // Verify secret matches hashlock
    require(keccak256(abi.encode(secret)) == immutables.hashlock, "InvalidSecret");
    
    // Transfer tokens
    IERC20(immutables.token.get()).safeTransfer(target, immutables.amount);  // 1 ETH to resolver
    _ethTransfer(msg.sender, immutables.safetyDeposit);  // Safety deposit to resolver
    
    emit EscrowWithdrawal(secret);
}

// 7. Resolver withdraws from Destination Chain (TRON)
function withdraw(bytes32 secret, Immutables calldata immutables) external {
    // Verify caller is taker (resolver)
    require(msg.sender == immutables.taker.get(), "InvalidCaller");
    
    // Verify timelock
    require(block.timestamp >= immutables.timelocks.get(TimelocksLib.Stage.DstWithdrawal), "InvalidTime");
    require(block.timestamp < immutables.timelocks.get(TimelocksLib.Stage.DstCancellation), "InvalidTime");
    
    // Call internal withdrawal
    _withdraw(secret, immutables);
}

function _withdraw(bytes32 secret, Immutables calldata immutables) internal {
    // Verify immutables and secret
    require(/* validation */, "Invalid");
    
    // Transfer tokens to maker (user)
    _uniTransfer(immutables.token.get(), immutables.maker.get(), immutables.amount);  // TRX to user
    _ethTransfer(msg.sender, immutables.safetyDeposit);  // Safety deposit to resolver
    
    emit EscrowWithdrawal(secret);
}
```

---

## **5. Function Call Sequence**

### **Complete Function Call Flow:**

#### **Setup Phase:**
1. `EscrowFactory.addressOfEscrowSrc()` - Get future escrow address
2. `EscrowFactory.addressOfEscrowDst()` - Get future escrow address

#### **Source Chain (Ethereum):**
3. `limitOrderProtocol.fillOrderArgs()` - Fill order (triggers escrow deployment)
4. `EscrowFactory._postInteraction()` - Called automatically by LOP
5. `EscrowFactory._deployEscrow()` - Deploy EscrowSrc clone
6. `IERC20.safeTransfer()` - Transfer ETH to escrow

#### **Destination Chain (TRON):**
7. `EscrowFactory.createDstEscrow()` - Deploy EscrowDst clone
8. `IERC20.safeTransferFrom()` - Transfer TRX to escrow

#### **Withdrawal Phase:**
9. `EscrowSrc.withdraw()` - Withdraw ETH from source escrow
10. `EscrowDst.withdraw()` - Withdraw TRX from destination escrow

#### **Cancellation Phase (if needed):**
11. `EscrowSrc.cancel()` - Cancel source escrow
12. `EscrowDst.cancel()` - Cancel destination escrow

#### **Emergency Functions:**
13. `EscrowSrc.publicWithdraw()` - Public withdrawal on source
14. `EscrowDst.publicWithdraw()` - Public withdrawal on destination
15. `EscrowSrc.publicCancel()` - Public cancellation on source
16. `BaseEscrow.rescueFunds()` - Emergency fund recovery

---

## **6. Source vs Destination**

### **Source Chain (Ethereum in ETH→TRON):**
- **Purpose**: Where user's original tokens are locked
- **Escrow**: `EscrowSrc` holds ETH tokens
- **Deployment**: Triggered by order fill through LOP
- **Withdrawal**: Resolver withdraws ETH to themselves
- **Cancellation**: User gets ETH back if swap fails

### **Destination Chain (TRON in ETH→TRON):**
- **Purpose**: Where user receives their desired tokens
- **Escrow**: `EscrowDst` holds TRX tokens
- **Deployment**: Manual call by resolver
- **Withdrawal**: Resolver sends TRX to user
- **Cancellation**: Resolver gets TRX back if swap fails

### **Key Differences:**

| Aspect | Source Chain | Destination Chain |
|--------|--------------|-------------------|
| **Token Flow** | User → Escrow | Resolver → Escrow → User |
| **Deployment Trigger** | Order fill (automatic) | Manual resolver call |
| **Withdrawal Recipient** | Resolver | User |
| **Cancellation Recipient** | User (original owner) | Resolver (original owner) |
| **Timelock Priority** | Higher priority | Lower priority |

---

## **7. Remix Deployment Guide**

### **Step-by-Step Remix Setup:**

#### **Step 1: Create Workspace**
1. Open [Remix IDE](https://remix.ethereum.org/)
2. Create new workspace: "1inch-cross-chain-swap"
3. Create folder structure:
   ```
   contracts/
   ├── libraries/
   └── interfaces/
   ```

#### **Step 2: Add All Required Files**
Copy these 18 files to Remix:

**Main Contracts (8 files):**
```
contracts/
├── EscrowFactory.sol
├── BaseEscrowFactory.sol
├── EscrowSrc.sol
├── EscrowDst.sol
├── BaseEscrow.sol
├── Escrow.sol
├── MerkleStorageInvalidator.sol
└── EscrowFactoryContext.sol
```

**Libraries (3 files):**
```
contracts/libraries/
├── ImmutablesLib.sol
├── TimelocksLib.sol
└── ProxyHashLib.sol
```

**Interfaces (7 files):**
```
contracts/interfaces/
├── IBaseEscrow.sol
├── IEscrow.sol
├── IEscrowSrc.sol
├── IEscrowDst.sol
├── IEscrowFactory.sol
├── IMerkleStorageInvalidator.sol
└── IResolverExample.sol
```

#### **Step 3: Configure Compiler**
1. Go to **Solidity Compiler** tab
2. Set compiler version: **0.8.23**
3. Enable optimization: **1000000 runs**
4. Set **via-IR**: true (if available)

#### **Step 4: Install Dependencies**
1. Go to **Package Manager** tab
2. Install packages:
   ```
   openzeppelin-contracts
   limit-order-protocol
   limit-order-settlement
   solidity-utils
   ```

#### **Step 5: Compile**
1. Click **Compile EscrowFactory.sol**
2. Ensure no compilation errors

#### **Step 6: Deploy**
1. Go to **Deploy & Run Transactions** tab
2. Select `EscrowFactory` contract
3. Set constructor parameters:

**For Ethereum:**
```solidity
limitOrderProtocol: 0x111111125421cA6dc452d289314280a0f8842A65
feeToken: 0x6B175474E89094C44Da98b954EedeAC495271d0F (DAI)
accessToken: 0xACCe550000159e70908C0499a1119D04e7039C28
owner: [Your Address]
rescueDelaySrc: 691200 (8 days)
rescueDelayDst: 691200 (8 days)
```

**For TRON:**
```solidity
limitOrderProtocol: 0x111111125421cA6dc452d289314280a0f8842A65
feeToken: [TRON DAI equivalent address]
accessToken: 0xACCe550000159e70908C0499a1119D04e7039C28
owner: [Your Address]
rescueDelaySrc: 691200 (8 days)
rescueDelayDst: 691200 (8 days)
```

#### **Step 7: Verify Deployment**
After deployment, call these functions to verify:
```solidity
// Check implementations were deployed
address srcImpl = factory.ESCROW_SRC_IMPLEMENTATION();
address dstImpl = factory.ESCROW_DST_IMPLEMENTATION();

// Should return valid addresses (not zero)
```

---

## **8. Security Mechanisms**

### **1. Secret-Based Unlocking**
```solidity
// Secret is hash of user's private key
bytes32 secret = keccak256(abi.encode(userPrivateKey));
bytes32 hashlock = keccak256(abi.encode(secret));

// Only correct secret unlocks escrows
require(keccak256(abi.encode(secret)) == immutables.hashlock, "InvalidSecret");
```

### **2. Deterministic Addresses**
```solidity
// Escrow addresses computed from swap parameters
bytes32 salt = immutables.hashMem();
address escrow = Create2.computeAddress(salt, PROXY_BYTECODE_HASH, FACTORY);

// Prevents front-running attacks
```

### **3. Timelock Protection**
```solidity
// Different time windows for different operations
enum Stage {
    SrcWithdrawal,        // Private withdrawal on source
    SrcPublicWithdrawal,  // Public withdrawal on source
    SrcCancellation,      // Private cancellation on source
    SrcPublicCancellation, // Public cancellation on source
    DstWithdrawal,        // Private withdrawal on destination
    DstPublicWithdrawal,  // Public withdrawal on destination
    DstCancellation       // Cancellation on destination
}
```

### **4. Access Token System**
```solidity
// Public operations require access token
modifier onlyAccessTokenHolder() {
    if (_ACCESS_TOKEN.balanceOf(msg.sender) == 0) revert InvalidCaller();
    _;
}
```

### **5. Safety Deposits**
```solidity
// Incentivize resolvers to complete swaps
uint256 safetyDeposit = extraDataArgs.deposits >> 128;
_ethTransfer(msg.sender, immutables.safetyDeposit);
```

---

## **9. Timelock System**

### **Timelock Structure:**
```solidity
struct SrcTimelocks {
    uint32 withdrawal;        // Private withdrawal period
    uint32 publicWithdrawal;  // Public withdrawal period
    uint32 cancellation;      // Private cancellation period
    uint32 publicCancellation; // Public cancellation period
}

struct DstTimelocks {
    uint32 withdrawal;        // Private withdrawal period
    uint32 publicWithdrawal;  // Public withdrawal period
    uint32 cancellation;      // Cancellation period
}
```

### **Time Flow Example:**
```
Source Chain (Ethereum):
[Deploy] --5min--> [Private Withdrawal] --5min--> [Public Withdrawal] --5min--> [Private Cancel] --5min--> [Public Cancel]

Destination Chain (TRON):
[Deploy] --5min--> [Private Withdrawal] --5min--> [Public Withdrawal] --5min--> [Cancel]
```

### **Timelock Functions:**
```solidity
// Get timelock value for specific stage
function get(Timelocks timelocks, Stage stage) internal pure returns (uint256) {
    uint256 data = Timelocks.unwrap(timelocks);
    uint256 bitShift = uint256(stage) * 32;
    return (data >> _DEPLOYED_AT_OFFSET) + uint32(data >> bitShift);
}

// Set deployment timestamp
function setDeployedAt(Timelocks timelocks, uint256 value) internal pure returns (Timelocks) {
    return Timelocks.wrap((Timelocks.unwrap(timelocks) & ~uint256(_DEPLOYED_AT_MASK)) | value << _DEPLOYED_AT_OFFSET);
}
```

---

## **10. Error Handling**

### **Common Errors:**

#### **1. Insufficient Balance**
```solidity
error InsufficientEscrowBalance();
// Thrown when escrow doesn't have required tokens
```

#### **2. Invalid Timelock**
```solidity
error InvalidTime();
// Thrown when operation attempted outside allowed time window
```

#### **3. Invalid Secret**
```solidity
error InvalidSecret();
// Thrown when secret doesn't match hashlock
```

#### **4. Invalid Caller**
```solidity
error InvalidCaller();
// Thrown when unauthorized address calls function
```

#### **5. Invalid Creation Time**
```solidity
error InvalidCreationTime();
// Thrown when destination escrow creation timing is invalid
```

### **Error Recovery:**
```solidity
// Emergency fund rescue
function rescueFunds(address token, uint256 amount, Immutables calldata immutables) external {
    require(msg.sender == immutables.taker.get(), "InvalidCaller");
    require(block.timestamp >= immutables.timelocks.rescueStart(RESCUE_DELAY), "InvalidTime");
    
    _uniTransfer(token, msg.sender, amount);
    emit FundsRescued(token, amount);
}
```

---

## **Summary**

### **Key Points:**
1. **18 files** need to be added to Remix for each network
2. **Same files** for both Ethereum and TRON (only parameters differ)
3. **EscrowSrc** deployed automatically when order is filled
4. **EscrowDst** deployed manually by resolver
5. **Secret-based** unlocking ensures atomic swaps
6. **Timelock system** prevents indefinite locking
7. **Safety deposits** incentivize proper execution

### **Deployment Checklist:**
- ✅ Add all 18 contract files to Remix
- ✅ Install external dependencies
- ✅ Set correct compiler settings
- ✅ Deploy EscrowFactory with correct parameters
- ✅ Verify implementation addresses
- ✅ Test basic functionality

This system ensures **atomic cross-chain swaps** where either both parties get their desired tokens or neither does, with strong security mechanisms and economic incentives for proper execution! 🚀